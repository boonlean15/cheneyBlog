<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ByteBuf | cheney blog</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="human is animal">
    
    <link rel="preload" href="/cheneyBlog/assets/css/0.styles.f77d735e.css" as="style"><link rel="preload" href="/cheneyBlog/assets/js/app.2a1bc94b.js" as="script"><link rel="preload" href="/cheneyBlog/assets/js/2.74bbeaff.js" as="script"><link rel="preload" href="/cheneyBlog/assets/js/1.893c586b.js" as="script"><link rel="preload" href="/cheneyBlog/assets/js/90.dc99d8c5.js" as="script"><link rel="prefetch" href="/cheneyBlog/assets/js/10.6a8c38aa.js"><link rel="prefetch" href="/cheneyBlog/assets/js/100.95e5021c.js"><link rel="prefetch" href="/cheneyBlog/assets/js/101.06202c38.js"><link rel="prefetch" href="/cheneyBlog/assets/js/102.f6b0fe8b.js"><link rel="prefetch" href="/cheneyBlog/assets/js/103.c61e99ca.js"><link rel="prefetch" href="/cheneyBlog/assets/js/104.99642148.js"><link rel="prefetch" href="/cheneyBlog/assets/js/105.2ffa3b1f.js"><link rel="prefetch" href="/cheneyBlog/assets/js/106.51eefa60.js"><link rel="prefetch" href="/cheneyBlog/assets/js/107.dabe6fb6.js"><link rel="prefetch" href="/cheneyBlog/assets/js/108.9be5f1d7.js"><link rel="prefetch" href="/cheneyBlog/assets/js/109.6fefe289.js"><link rel="prefetch" href="/cheneyBlog/assets/js/11.fea60cf3.js"><link rel="prefetch" href="/cheneyBlog/assets/js/110.d31f031f.js"><link rel="prefetch" href="/cheneyBlog/assets/js/111.13279446.js"><link rel="prefetch" href="/cheneyBlog/assets/js/112.31d069b8.js"><link rel="prefetch" href="/cheneyBlog/assets/js/113.6cff2a43.js"><link rel="prefetch" href="/cheneyBlog/assets/js/114.1eba6be8.js"><link rel="prefetch" href="/cheneyBlog/assets/js/115.3238d6ad.js"><link rel="prefetch" href="/cheneyBlog/assets/js/116.a9a22106.js"><link rel="prefetch" href="/cheneyBlog/assets/js/117.fa2d4d36.js"><link rel="prefetch" href="/cheneyBlog/assets/js/118.301c5e19.js"><link rel="prefetch" href="/cheneyBlog/assets/js/119.705ed344.js"><link rel="prefetch" href="/cheneyBlog/assets/js/12.56b65f1c.js"><link rel="prefetch" href="/cheneyBlog/assets/js/120.bd50b801.js"><link rel="prefetch" href="/cheneyBlog/assets/js/121.b48f6d49.js"><link rel="prefetch" href="/cheneyBlog/assets/js/13.86734518.js"><link rel="prefetch" href="/cheneyBlog/assets/js/14.95961084.js"><link rel="prefetch" href="/cheneyBlog/assets/js/15.b08f5e79.js"><link rel="prefetch" href="/cheneyBlog/assets/js/16.a1ae088e.js"><link rel="prefetch" href="/cheneyBlog/assets/js/17.aa2b462d.js"><link rel="prefetch" href="/cheneyBlog/assets/js/18.6be81e2e.js"><link rel="prefetch" href="/cheneyBlog/assets/js/19.8ef002e9.js"><link rel="prefetch" href="/cheneyBlog/assets/js/20.2b975910.js"><link rel="prefetch" href="/cheneyBlog/assets/js/21.ba290175.js"><link rel="prefetch" href="/cheneyBlog/assets/js/22.c26c4966.js"><link rel="prefetch" href="/cheneyBlog/assets/js/23.cf3ffada.js"><link rel="prefetch" href="/cheneyBlog/assets/js/24.b96b79d1.js"><link rel="prefetch" href="/cheneyBlog/assets/js/25.b2f6097f.js"><link rel="prefetch" href="/cheneyBlog/assets/js/26.3ed02549.js"><link rel="prefetch" href="/cheneyBlog/assets/js/27.a1654b4e.js"><link rel="prefetch" href="/cheneyBlog/assets/js/28.bf32292c.js"><link rel="prefetch" href="/cheneyBlog/assets/js/29.2aa47805.js"><link rel="prefetch" href="/cheneyBlog/assets/js/3.4dcf44ec.js"><link rel="prefetch" href="/cheneyBlog/assets/js/30.319dc4f2.js"><link rel="prefetch" href="/cheneyBlog/assets/js/31.8f00303a.js"><link rel="prefetch" href="/cheneyBlog/assets/js/32.7596994e.js"><link rel="prefetch" href="/cheneyBlog/assets/js/33.5f609bb9.js"><link rel="prefetch" href="/cheneyBlog/assets/js/34.dc9b8b8c.js"><link rel="prefetch" href="/cheneyBlog/assets/js/35.061afdb0.js"><link rel="prefetch" href="/cheneyBlog/assets/js/36.d11c9e8e.js"><link rel="prefetch" href="/cheneyBlog/assets/js/37.c5066515.js"><link rel="prefetch" href="/cheneyBlog/assets/js/38.d6778771.js"><link rel="prefetch" href="/cheneyBlog/assets/js/39.05994203.js"><link rel="prefetch" href="/cheneyBlog/assets/js/4.f2aa92b5.js"><link rel="prefetch" href="/cheneyBlog/assets/js/40.b8f601e0.js"><link rel="prefetch" href="/cheneyBlog/assets/js/41.957ff061.js"><link rel="prefetch" href="/cheneyBlog/assets/js/42.58b92311.js"><link rel="prefetch" href="/cheneyBlog/assets/js/43.2d130ce6.js"><link rel="prefetch" href="/cheneyBlog/assets/js/44.6d78ab81.js"><link rel="prefetch" href="/cheneyBlog/assets/js/45.25898937.js"><link rel="prefetch" href="/cheneyBlog/assets/js/46.ca07bbf9.js"><link rel="prefetch" href="/cheneyBlog/assets/js/47.8c80545a.js"><link rel="prefetch" href="/cheneyBlog/assets/js/48.b5322896.js"><link rel="prefetch" href="/cheneyBlog/assets/js/49.9368b4fb.js"><link rel="prefetch" href="/cheneyBlog/assets/js/5.7e868145.js"><link rel="prefetch" href="/cheneyBlog/assets/js/50.ea5e2b58.js"><link rel="prefetch" href="/cheneyBlog/assets/js/51.68eb1490.js"><link rel="prefetch" href="/cheneyBlog/assets/js/52.f3948645.js"><link rel="prefetch" href="/cheneyBlog/assets/js/53.6218805a.js"><link rel="prefetch" href="/cheneyBlog/assets/js/54.96cd8581.js"><link rel="prefetch" href="/cheneyBlog/assets/js/55.fdea5d39.js"><link rel="prefetch" href="/cheneyBlog/assets/js/56.97d4b64f.js"><link rel="prefetch" href="/cheneyBlog/assets/js/57.91b248d3.js"><link rel="prefetch" href="/cheneyBlog/assets/js/58.b056e048.js"><link rel="prefetch" href="/cheneyBlog/assets/js/59.680956e8.js"><link rel="prefetch" href="/cheneyBlog/assets/js/6.197d190f.js"><link rel="prefetch" href="/cheneyBlog/assets/js/60.eb17eee3.js"><link rel="prefetch" href="/cheneyBlog/assets/js/61.d45b47d8.js"><link rel="prefetch" href="/cheneyBlog/assets/js/62.f7960757.js"><link rel="prefetch" href="/cheneyBlog/assets/js/63.f447bf98.js"><link rel="prefetch" href="/cheneyBlog/assets/js/64.f4ec515f.js"><link rel="prefetch" href="/cheneyBlog/assets/js/65.2405c942.js"><link rel="prefetch" href="/cheneyBlog/assets/js/66.5bd91fb7.js"><link rel="prefetch" href="/cheneyBlog/assets/js/67.8f12da6a.js"><link rel="prefetch" href="/cheneyBlog/assets/js/68.611bfb1c.js"><link rel="prefetch" href="/cheneyBlog/assets/js/69.43ed7d12.js"><link rel="prefetch" href="/cheneyBlog/assets/js/7.a32ca284.js"><link rel="prefetch" href="/cheneyBlog/assets/js/70.8b00c2ae.js"><link rel="prefetch" href="/cheneyBlog/assets/js/71.dcd77349.js"><link rel="prefetch" href="/cheneyBlog/assets/js/72.7b34136e.js"><link rel="prefetch" href="/cheneyBlog/assets/js/73.ab4ef9bb.js"><link rel="prefetch" href="/cheneyBlog/assets/js/74.e2630224.js"><link rel="prefetch" href="/cheneyBlog/assets/js/75.15f7dcb5.js"><link rel="prefetch" href="/cheneyBlog/assets/js/76.f893ca76.js"><link rel="prefetch" href="/cheneyBlog/assets/js/77.54a2add0.js"><link rel="prefetch" href="/cheneyBlog/assets/js/78.3b264378.js"><link rel="prefetch" href="/cheneyBlog/assets/js/79.66881ae7.js"><link rel="prefetch" href="/cheneyBlog/assets/js/80.2e5615f6.js"><link rel="prefetch" href="/cheneyBlog/assets/js/81.270576ba.js"><link rel="prefetch" href="/cheneyBlog/assets/js/82.02352aa6.js"><link rel="prefetch" href="/cheneyBlog/assets/js/83.54d83062.js"><link rel="prefetch" href="/cheneyBlog/assets/js/84.2e26223b.js"><link rel="prefetch" href="/cheneyBlog/assets/js/85.023319ec.js"><link rel="prefetch" href="/cheneyBlog/assets/js/86.19288d57.js"><link rel="prefetch" href="/cheneyBlog/assets/js/87.55c31ac7.js"><link rel="prefetch" href="/cheneyBlog/assets/js/88.34d079a6.js"><link rel="prefetch" href="/cheneyBlog/assets/js/89.857e35a8.js"><link rel="prefetch" href="/cheneyBlog/assets/js/91.734ff8ad.js"><link rel="prefetch" href="/cheneyBlog/assets/js/92.9adf7eb3.js"><link rel="prefetch" href="/cheneyBlog/assets/js/93.4de9a7a4.js"><link rel="prefetch" href="/cheneyBlog/assets/js/94.b481eb28.js"><link rel="prefetch" href="/cheneyBlog/assets/js/95.a0996300.js"><link rel="prefetch" href="/cheneyBlog/assets/js/96.235a4969.js"><link rel="prefetch" href="/cheneyBlog/assets/js/97.a8dc967f.js"><link rel="prefetch" href="/cheneyBlog/assets/js/98.27bc98d8.js"><link rel="prefetch" href="/cheneyBlog/assets/js/99.95e5b063.js"><link rel="prefetch" href="/cheneyBlog/assets/js/vendors~docsearch.d856fa52.js">
    <link rel="stylesheet" href="/cheneyBlog/assets/css/0.styles.f77d735e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/cheneyBlog/" class="home-link router-link-active"><!----> <span class="site-name">cheney blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/cheneyBlog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/cheneyBlog/java/jdkRelationship.html" class="nav-link">
  JAVA
</a></div><div class="nav-item"><a href="http://www.lvyestudy.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  前端
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/boonlean15" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/cheneyBlog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/cheneyBlog/java/jdkRelationship.html" class="nav-link">
  JAVA
</a></div><div class="nav-item"><a href="http://www.lvyestudy.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  前端
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/boonlean15" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/cheneyBlog/markdown/" class="sidebar-link">Markdown语法</a></li><li><a href="/cheneyBlog/buildBlog/buildBlog.html" class="sidebar-link">Vuepress构建项目</a></li><li><a href="/cheneyBlog/how-to-learn-english/how-to-learn-english.html" class="sidebar-link">学好英语</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>SQL</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JAVA基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>并发理论基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>并发工具类</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>并发设计模式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>并发案例分析</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>其他并发模型</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>NIO</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/cheneyBlog/rpc/rpc.html" class="sidebar-link">RPC</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Netty in action</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/cheneyBlog/netty/netty_nio_event.html" class="sidebar-link">Netty 异步和事件驱动</a></li><li><a href="/cheneyBlog/netty/netty_first_app.html" class="sidebar-link">第一个netty应用</a></li><li><a href="/cheneyBlog/netty/netty_component_design.html" class="sidebar-link">netty组件和设计</a></li><li><a href="/cheneyBlog/netty/netty_transport.html" class="sidebar-link">netty传输</a></li><li><a href="/cheneyBlog/netty/netty_bytebuf.html" aria-current="page" class="active sidebar-link">ByteBuf</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cheneyBlog/netty/netty_bytebuf.html#bytebuf优点" class="sidebar-link">ByteBuf优点</a></li><li class="sidebar-sub-header"><a href="/cheneyBlog/netty/netty_bytebuf.html#bytebuf类" class="sidebar-link">ByteBuf类</a></li><li class="sidebar-sub-header"><a href="/cheneyBlog/netty/netty_bytebuf.html#使用模式" class="sidebar-link">使用模式</a></li><li class="sidebar-sub-header"><a href="/cheneyBlog/netty/netty_bytebuf.html#字节级操作" class="sidebar-link">字节级操作</a></li><li class="sidebar-sub-header"><a href="/cheneyBlog/netty/netty_bytebuf.html#bytebufholder" class="sidebar-link">ByteBufHolder</a></li><li class="sidebar-sub-header"><a href="/cheneyBlog/netty/netty_bytebuf.html#bytebuf实例管理方式" class="sidebar-link">ByteBuf实例管理方式</a></li><li class="sidebar-sub-header"><a href="/cheneyBlog/netty/netty_bytebuf.html#引用计数" class="sidebar-link">引用计数</a></li></ul></li><li><a href="/cheneyBlog/netty/netty_channelhandler.html" class="sidebar-link">ChannelHandler和ChannelPipeline</a></li><li><a href="/cheneyBlog/netty/netty_eventloop.html" class="sidebar-link">EventLoop和线程模型</a></li><li><a href="/cheneyBlog/netty/netty_bootstrap.html" class="sidebar-link">引导Boostrap</a></li><li><a href="/cheneyBlog/netty/netty_embedded.html" class="sidebar-link">单元测试EmbeddedChannel</a></li><li><a href="/cheneyBlog/netty/netty_encode_frame.html" class="sidebar-link">编解码器框架</a></li><li><a href="/cheneyBlog/netty/netty_encode_frame_pre.html" class="sidebar-link">预置的ChannelHandler和编解码器</a></li><li><a href="/cheneyBlog/netty/netty_protocol.html" class="sidebar-link">网络协议WebSocket</a></li><li><a href="/cheneyBlog/netty/netty_udp.html" class="sidebar-link">UDP广播事件</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>spring cloud</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/cheneyBlog/authentication/authentication.html" class="sidebar-link">认证</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Mybatis</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Maven</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CICD</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>AI知识</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>springboot</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>其他</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="bytebuf"><a href="#bytebuf" class="header-anchor">#</a> ByteBuf</h1> <p>Netty的数据容器 ByteBuf的API，通过ByteBuf和ByteBufHolder暴露</p> <blockquote><p>API的详细信息、用例、内存分配</p></blockquote> <blockquote><p>java nio使用ByteBuffer作为它的字节容器，但过于复杂，有些繁琐。Netty的ByteBuffer替代品ByteBuf，一个强大的实现，解决了JDK API的局限性，又为网络应用程序的开发者提供了更好的API</p></blockquote> <h2 id="bytebuf优点"><a href="#bytebuf优点" class="header-anchor">#</a> ByteBuf优点</h2> <ul><li>可被用户自定义的缓冲区类型扩展</li> <li>内置的复合缓冲区类型实现了透明的零拷贝</li> <li>容量可以按需增长(类似StringBuilder)</li> <li>读写切换不需要调用ByteBuffer的flip()方法</li> <li>读写使用了不同的索引</li> <li>支持方法的链式调用</li> <li>支持引用计数</li> <li>支持池化</li></ul> <h2 id="bytebuf类"><a href="#bytebuf类" class="header-anchor">#</a> ByteBuf类</h2> <img width="800" src="https://boonlean15.github.io/cheneyBlog/images/netty/2.png" alt="png"> <h3 id="索引-读写会改变索引-get-set不会"><a href="#索引-读写会改变索引-get-set不会" class="header-anchor">#</a> 索引 读写会改变索引 get set不会</h3> <p>ByteBuf拥有一个读索引和写索引：ReaderIndex和WriteIndex</p> <blockquote><p>如果ReaderIndex到WriteIndex到位置，然后继续读，则会IndexOutofBoundsException、可以指定ByteBuf的最大容量</p></blockquote> <h2 id="使用模式"><a href="#使用模式" class="header-anchor">#</a> 使用模式</h2> <h3 id="堆缓冲区"><a href="#堆缓冲区" class="header-anchor">#</a> 堆缓冲区</h3> <blockquote><p>最常用的byteBuf模式是将数据存储在JVM的堆空间中，这种模式称为支撑数组。可在没有池化的情况下提供快速的分配和释放。</p></blockquote> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ByteBuf</span> heapBuf <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>heapBuf<span class="token punctuation">.</span><span class="token function">hasArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// 检查ByteBuf是否有一个支撑数组</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> heapBuf<span class="token punctuation">.</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//如果有，获取对应数组的引用</span>
    <span class="token keyword">int</span> offset <span class="token operator">=</span> heapBuf<span class="token punctuation">.</span><span class="token function">arrayOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> heapBuf<span class="token punctuation">.</span><span class="token function">readerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//计算第一个字节的偏移量    </span>
    <span class="token keyword">int</span> length <span class="token operator">=</span> heapBuf<span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取可读字节数</span>
    <span class="token function">handleArray</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用数组、偏移量、长度作为参数调用你的方法</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="直接缓冲区"><a href="#直接缓冲区" class="header-anchor">#</a> 直接缓冲区</h3> <blockquote><p>JDK的ByteBuffer允许JVM通过本地调用来分配内存、为了避免在每次调用本地I/O操作之前将缓冲区的内容复制到一个中间缓冲区。</p></blockquote> <blockquote><p>直接缓冲区的内容驻留在堆之外，直接缓冲区对于网络数据传输是理想的选择。如果数据在一个堆上分配的缓冲区中，通过socket发送它之前，JVM会在内部把你的缓冲区复制到一个直接缓冲区中</p></blockquote> <ul><li>缺点
<ul><li>分配和释放都较为昂贵</li> <li>数据不是在堆上，需要进行一次复制</li></ul></li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ByteBuf</span> directBuf <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>directBuf<span class="token punctuation">.</span><span class="token function">hasArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//检查ByteBuf 是否由支撑数组，如果不是，则这是一个直接缓冲区</span>
    <span class="token keyword">int</span> length <span class="token operator">=</span>  directBuf<span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取刻度字节数</span>
    <span class="token keyword">byte</span>  array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//分配一个新的数组保存具有该长度的字节数据</span>
    directBuf<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>directBuf<span class="token punctuation">.</span><span class="token function">readerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//复制字节到该数组</span>
    <span class="token function">handleArray</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用数组，偏移量和长度作为参数调用你的方法</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="复合缓冲区"><a href="#复合缓冲区" class="header-anchor">#</a> 复合缓冲区</h3> <blockquote><p>为多个ByteBuf提供一个聚合视图，可以根据需要添加或删除ByteBuf实例</p></blockquote> <p>CompositeByteBuf ByteBuf的子类，提供将多个缓冲区表示为单个合并缓冲区。如果只有一个实例，hasArray方法调用将返回该组件的hasArray方法的值，否则将返回false
<img width="800" src="https://boonlean15.github.io/cheneyBlog/images/netty/3.png" alt="png"></p> <p><strong>使用CompositeByteBuf的复合缓冲区模式</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">CompositeByteBuf</span> messageBuf <span class="token operator">=</span> <span class="token class-name">Unpooled</span><span class="token punctuation">.</span><span class="token function">compositeBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ByteBuf</span> headerBuf <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token comment">//can be backing or direct</span>
<span class="token class-name">ByteBuf</span> bodyBuf <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token comment">//can be backing or direct</span>
messagebuf<span class="token punctuation">.</span><span class="token function">addComponents</span><span class="token punctuation">(</span>headerBuf<span class="token punctuation">,</span>bodyBuf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将ByteBuf实例追加到compositeByteBuf</span>
messageBuf<span class="token punctuation">.</span><span class="token function">removeComponent</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除位于索引0的ByteBuf</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">ByteBuf</span> buf<span class="token operator">:</span> messageBuf<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//遍历所有ByteBuf实例</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>访问compositeByteBuf中的数据</strong></p> <p>CompositeByteBuf可能不支持访问其支撑数组</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">CompositeByteBuf</span> comBuf <span class="token operator">=</span> <span class="token class-name">Unpooled</span><span class="token punctuation">.</span><span class="token function">compositeBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> length <span class="token operator">=</span> comBuf<span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Byte</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>
comBuf<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>comBuf<span class="token punctuation">.</span><span class="token function">readerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将字节读到数组中</span>
<span class="token function">handleArray</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> array<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><blockquote><p>Netty使用了CompositeByteBuf来优化套接字的IO操作，尽可能的消除由JDK缓冲区实现所导致的性能以及内存使用率的惩罚。<strong>(指的是：本地IO操作之前将缓冲区复制到一个中间缓冲区、包含堆上分配的缓冲区，在套接字发送前，JVM内部把缓冲区复制到直接缓冲区中)</strong></p></blockquote></li></ul> <h2 id="字节级操作"><a href="#字节级操作" class="header-anchor">#</a> 字节级操作</h2> <p>指的是操作ByteBuf的数据，即操作的字节。跟普通java数组一样，ByteBuf的索引是从零开始的</p> <h3 id="随机访问索引"><a href="#随机访问索引" class="header-anchor">#</a> 随机访问索引</h3> <blockquote><p>使用需要一个索引值参数的方法之一来访问数据既不会改变readerIndex也不会改变writeIndex。<strong>调用readerIndex(index)或writerIndex(index)手动移动索引</strong></p></blockquote> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ByteBuf</span> buff <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>buff<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">byte</span> b <span class="token operator">=</span> buff<span class="token punctuation">.</span><span class="token function">getByte</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div> <img width="800" src="https://boonlean15.github.io/cheneyBlog/images/netty/4.png" alt="png"> <h3 id="可丢弃字节"><a href="#可丢弃字节" class="header-anchor">#</a> 可丢弃字节</h3> <blockquote><p>调用discardReadBytes()方法后，丢弃并回收空间</p></blockquote> <img width="800" src="https://boonlean15.github.io/cheneyBlog/images/netty/5.png" alt="png"> <blockquote><p>频繁地调用discardReadBytes()方法以确保可写分段的最大化，但极有可能会导致内存复制，因为可读字节（图中标记为CONTENT的部分）必须被移动到缓冲区的开始位置。建议只在有真正需要的时候才这样做，例如，当内存非常宝贵的时候</p></blockquote> <h3 id="可读字节"><a href="#可读字节" class="header-anchor">#</a> 可读字节</h3> <blockquote><p>ByteBuf的刻度字节分段存储来实际数据，新分配、包装的、复制的缓冲区默认的readerIndex值为0.</p></blockquote> <p>被调用的方法需要一个ByteBuf参数作为写入的目标，并没指定目标索引参数，那么该目标缓冲区的writerIndex也将被增加</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token function">readBytes</span><span class="token punctuation">(</span><span class="token class-name">ByteBuf</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre></div><p>示例：读取所有数据</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ByteBuf</span> buffer <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">readByte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="可写字节"><a href="#可写字节" class="header-anchor">#</a> 可写字节</h3> <blockquote><p>新分配的缓冲区的writerIndex默认值为0，名为write开头的操作都将从当前的writerIndex处开始写数据</p></blockquote> <p>writeBytes(Bytebuf dest) 源缓冲区中的readerIndex同样被增加相同的大小、尝试写入超过capacity的数据，IndexOutOfBoundException</p> <p>示例：写数据</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ByteBuf</span> buffer <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">writeableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//缓冲区是否还有足够空间写</span>
    buffer<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="索引管理"><a href="#索引管理" class="header-anchor">#</a> 索引管理</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token function">markReaderIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//标记read索引</span>
<span class="token function">markWriterIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//标记write索引</span>
<span class="token function">resetReaderIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//重置read索引</span>
<span class="token function">resetWriterIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//重置write索引</span>

<span class="token function">readerIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//移动read索引</span>
<span class="token function">writerIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//移动write索引</span>

<span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//readerIndex和writerIndex设置为0  不会清除内存中的内容 </span>
</code></pre></div><p>clear方法</p> <blockquote><p>clear()比discardReadBytes()轻量，只是重置索引而不会复制任何内容</p></blockquote> <img width="800" src="https://boonlean15.github.io/cheneyBlog/images/netty/6.png" alt="png"> <h3 id="查找操作"><a href="#查找操作" class="header-anchor">#</a> 查找操作</h3> <ul><li>indexOf() 方法最常用,确定指定值的索引</li> <li>复杂查找 借助ByteBufProcessor，它有很多内置的常用值</li> <li>ByteBufProcessor接口只有一个 process(byte var1)方法</li> <li>forEachByte(ByteBufProcessor.FIND_NUL)</li></ul> <p>示例：“使用ByteBufProcessor来寻找\r”</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ByteBuf</span> buffer <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> index <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">forEachByte</span><span class="token punctuation">(</span><span class="token class-name">ByteBufProcessor</span><span class="token punctuation">.</span><span class="token constant">FIND_CR</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="派生缓冲区"><a href="#派生缓冲区" class="header-anchor">#</a> 派生缓冲区</h3> <ul><li>duplicate()</li> <li>slice()</li> <li>slice(int,int)</li> <li>Unpooled.unmodifiableBuffer(...)</li> <li>order(ByteOrder)</li> <li>readSlice(int)</li></ul> <blockquote><p>都会返回一个新的实例，它具有自己的读写索引和标记索引，但内部存储是共享的，即引用，如果修改了数据，则源数据对应的也被修改。但复制的代价很低廉，可以避开复制内存的开销</p></blockquote> <p>如果需要复制一个不共享的，采用copy()/copy(int,int)方法</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Charset</span> utf8 <span class="token operator">=</span> <span class="token class-name">Charset</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;UTF-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token class-name">ByteBuf</span> buf <span class="token operator">=</span> <span class="token class-name">Unpooled</span><span class="token punctuation">.</span><span class="token function">copiedBuffer</span><span class="token punctuation">(</span><span class="token string">&quot;Netty in Action rocks!&quot;</span><span class="token punctuation">,</span> utf8<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//创建ByteBuf 以保存所提供的字符串的字节</span>
 <span class="token class-name">ByteBuf</span> copy <span class="token operator">=</span> buf<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　 <span class="token comment">//创建该ByteBuf 从索引0 开始到索引15结束的分段的副本</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>copy<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>utf8<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　 <span class="token comment">//将打印“Netty in Action</span>
buf<span class="token punctuation">.</span><span class="token function">setByte</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token char">'J'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　 <span class="token comment">//更新索引0 处的字节 </span>
<span class="token keyword">assert</span> buf<span class="token punctuation">.</span><span class="token function">getByte</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">!=</span> copy<span class="token punctuation">.</span><span class="token function">getByte</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将会成功，因为数据不是共享的</span>
</code></pre></div><h3 id="读写操作"><a href="#读写操作" class="header-anchor">#</a> 读写操作</h3> <ul><li>get/set操作，从指定的索引开始，并保持索引不变</li> <li>read/write操作，从指定的索引开始，索引对应变化</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将该缓冲区中从给定索引开始的数据传送到指定目的地</span>
<span class="token function">setByte</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置给定索引处的字节值</span>
<span class="token function">readByte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回当前readerIndex的字节，readerIndex增加1</span>
<span class="token function">readMedium</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回当前readerIndex处的24位的中等int值，并将readerIndex增加3</span>
<span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回当前readerIndex的int值，并将readerIndex增加4”</span>
<span class="token function">readBytes</span><span class="token punctuation">(</span><span class="token class-name">ByteBuf</span> <span class="token operator">|</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> destination<span class="token punctuation">,</span> <span class="token keyword">int</span> dstIndex <span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token keyword">int</span> length<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将当前ByteBuf中从当前readerIndex处开始的（如果设置了，length长度的字节）数据传送到一个目标ByteBuf或者byte[]，从目标的dstIndex开始的位置。本地的readerIndex将被增加已经传输的字节数</span>
<span class="token function">writeByte</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在当前writerIndex处写入一个字节值，并将writerIndex增加1</span>
<span class="token function">writeBytes</span><span class="token punctuation">(</span><span class="token class-name">ByteBuf</span> source <span class="token operator">|</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token keyword">int</span> srcIndex <span class="token punctuation">,</span><span class="token keyword">int</span> length<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从当前writerIndex开始，传输来自于指定源（ByteBuf或者byte[]）的数据。如果提供了srcIndex和length，则从srcIndex开始读取，并且处理长度为length的字节。当前writerIndex将会被增加所写入的字节数”</span>
</code></pre></div> <img width="800" src="https://boonlean15.github.io/cheneyBlog/images/netty/7.png" alt="png"> <h2 id="bytebufholder"><a href="#bytebufholder" class="header-anchor">#</a> ByteBufHolder</h2> <blockquote><p>除了实际数据负载外，还需要存储各种属性,例如Http响应。netty提供了ByteBufHolder来处理，它支持缓冲区池化，可以从池中借用ByteBuf，在需要时自动释放</p></blockquote> <ul><li>content() 返回ByteBufHolder所持有的ByteBuf</li> <li>copy() 深拷贝这个ByteBufHolder，包括它所包含的ByteBuf的非共享拷贝</li> <li>duplicate() 浅拷贝这个ByteBufHolder</li></ul> <h2 id="bytebuf实例管理方式"><a href="#bytebuf实例管理方式" class="header-anchor">#</a> ByteBuf实例管理方式</h2> <h3 id="按需分配bytebufallocator"><a href="#按需分配bytebufallocator" class="header-anchor">#</a> 按需分配ByteBufAllocator</h3> <blockquote><p>Netty通过ByteBufAllocator实现ByteBuf的池化，用来分配任意类型的ByteBuf实例。它不会改变ByteBuf API</p></blockquote> <ul><li>可以从Channel或者ChannelHandlerContext获取ByteBufAllocator</li> <li>netty默认使用pooledByteBufAllocator，可通过ChannelConfig或引导时配置</li> <li>ByteBufAllocator实现
<ul><li>PooledByteBufAllocator 池化了ByteBuf实例以提高性能并最大限度减少内存碎片。jemalloc-分配内存的方法-被大量现代操作系统采用</li> <li>UnpooledByteBufAllocator 不池化ByteBuf实例，每次调用都是一个新的实例</li></ul></li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token function">buffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">buffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">buffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> maxCapaccity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回一个基于堆或直接内存存储的ByteBuf</span>
<span class="token function">heapBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">heapBuffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">heapBuffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span><span class="token keyword">int</span> maxCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回一个基于堆内存存储的ByteBuf</span>
<span class="token function">directBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">directBuffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">directBuffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span><span class="token keyword">int</span> maxCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回一个基于直接内存存储的ByteBuf</span>
<span class="token function">compositeBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回一个可以通过添加最大到指定数目的基于堆或直接内存存储的缓冲区来拓展的CompositeByteBuf</span>
<span class="token function">ioBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回一个用于套接字的I/O操作的ByteBuf</span>
</code></pre></div><h3 id="unpooled缓冲区"><a href="#unpooled缓冲区" class="header-anchor">#</a> Unpooled缓冲区</h3> <blockquote><p>未能获取ByteBufAllocator的情况，netty提供了Unpooled的工具类，静态辅助方法创建未池化的ByteBuf实例。</p></blockquote> <div class="language-java extra-class"><pre class="language-java"><code><span class="token function">buffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">buffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">buffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span><span class="token keyword">int</span> maxCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回一个未池化的基于堆内存存储的ByteBuf</span>
<span class="token function">directBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回一个未池化的基于直接内存存储的ByteBuf</span>
<span class="token function">wrappedBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回一个包装了给定数据的ByteBuf</span>
<span class="token function">copiedBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回一个复制了给定数据的ByteBuf</span>
</code></pre></div><ul><li>Unpooled使得ByteBuf可用于不需要Netty的其他组件的非网络项目，使得其能得益于高性能的可扩展的缓冲区API</li></ul> <h3 id="bytebufutil"><a href="#bytebufutil" class="header-anchor">#</a> ByteBufUtil</h3> <blockquote><p>ByteBufUtil提供操作ByteBuf的静态的辅助方法。和池化无关</p></blockquote> <ul><li>hexdump() 十六进制的表示形式打印ByteBuf的内容</li> <li>boolean equals(ByteBuf，ByteBuf) 判断两个ByteBuf实例的相等性</li></ul> <h2 id="引用计数"><a href="#引用计数" class="header-anchor">#</a> 引用计数</h2> <p>Netty第4版中为ByteBuf和ByteBufHolder引入引用计数，实现自ReferenceCounted</p> <blockquote><p>引用计数：通过在某个对象所持有的资源不再被其他对象引用时释放该对象所持有的资源来优化内存使用和性能的技术</p></blockquote> <ul><li>通常以活动的引用计数为1开始，引用计数大于0，对象不会被释放。减少到0时，该实例会被释放。</li> <li>已经释放到对象应该不可在用了</li> <li>引用计数对于池化的实现是至关重要的，它降低内存分配的开销</li> <li>谁负责释放：一般由最后访问(引用计数)对象的那一方负责释放</li></ul> <p>示例：引用计数</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token class-name">ByteBufAllocator</span> alloc <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取ByteBufAllocator</span>
<span class="token class-name">ByteBuf</span> buff <span class="token operator">=</span> alloc<span class="token punctuation">.</span><span class="token function">directbuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从ByteBufAllocator分配一个ByteBuf</span>
<span class="token keyword">assert</span> buff<span class="token punctuation">.</span><span class="token function">refCnt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//检查引用计数是否为预期的1</span>
</code></pre></div><p>示例：释放引用计数的对象</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ByteBuf</span> buffer <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> released <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//减少该对象的活动引用。当减少到0，该对象呗释放，并且该方法返回true</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/cheneyBlog/netty/netty_transport.html" class="prev">
        netty传输
      </a></span> <span class="next"><a href="/cheneyBlog/netty/netty_channelhandler.html">
        ChannelHandler和ChannelPipeline
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/cheneyBlog/assets/js/app.2a1bc94b.js" defer></script><script src="/cheneyBlog/assets/js/2.74bbeaff.js" defer></script><script src="/cheneyBlog/assets/js/1.893c586b.js" defer></script><script src="/cheneyBlog/assets/js/90.dc99d8c5.js" defer></script>
  </body>
</html>
