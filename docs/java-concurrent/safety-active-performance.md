# 安全性、活跃性、性能问题

## 安全性
### 概述
> 即正确性，程序按我们预期的执行，不要让我们感到意外
- 线程安全的程序
> 理论上线程安全的程序，就要避免出现原子性问题、可见性问题和有序性问题

### 保证线程安全性
- 不共享数据
- 数据状态不发生变化 
>（线程本地存储、不变模式），然而现实中必须共享数据

### 数据竞争 竞态条件
- 数据竞争
> 存在共享数据并且该数据会发生变化，通俗地讲就是有多个线程会同时读写同一数据
- 竞态条件
> 所谓竞态条件，指的是程序的执行结果依赖线程执行的顺序。或程序的执行依赖于某个状态变量

### 数据竞争和竞态条件问题，又该如何保证线程的安全性呢
> 这两类问题，都可以用互斥这个技术方案，而实现互斥的方案有很多，CPU 提供了相关的互斥指令，操作系统、编程语言也会提供相关的 API。从逻辑上来看，我们可以统一归为：锁

## 活跃性
### 概述
> 某个操作无法执行下去

### 死锁 
- 概述
> 一组互相竞争资源的线程互相等待，导致两个线程无休止的阻塞了
- 出现原因
> 互斥、占有且等待、不可抢占、循环等待
- 解决方案
> 打破导致死锁的条件：占有且等待(wait-notify)、不可抢占、循环等待(排序法获取锁)

### 活锁 
- 概述
> a谦让b，b谦让a，来来回回碰到,如人走路时。人灵活，可解决，机器不一定
- 解决方案
> 等待一个随机时间再谦让,Raft(分布式一致性算法)也有用到

### 饥饿 
- 概述
> 无法访问所需资源导致无法执行下去
- 出现原因
>  不患寡而患不均，线程优先级不均，导致优先级低的线程执行机会很小。持有锁的线程执行时间过长
- 解决方案
> 有三种方案：一是保证资源充足，二是公平地分配资源，三就是避免持有锁的线程长时间执行
- 公平地分配资源
> 在并发编程里，主要是使用公平锁。所谓公平锁，是一种先来后到的方案，线程的等待是有顺序的，排在等待队列前面的线程会优先获得资源

## 性能
- 概述
> 使用锁要非常小心，但小心过度，则可能导致串行化的范围过大，导致性能问题。
### 串行百分比
- 串行百分比
> 临界区都是串行的，非临界区都是并行的，用单线程执行临界区的时间/用单线程执行(临界区+非临界区)的时间就是串行百分比

- 阿姆达尔（Amdahl）定律 代表了处理器并行运算之后效率提升的能力
> s = 1 / ((1-p)+ (p/n)),其中p代表的是并行率，则1-p代表的是串行百分比，加入串行百分比是5%，那么无论我们采用什么技术，最多只能提高20倍性能

### 解决方案
- 使用无锁数据结构和算法
> 线程本地存储、写入时复制(copy-on-write)、乐观锁等。java sdk的原子类、disruptor无锁内存队列
- 减少持有锁的时间
> 例如使用细粒度的锁：concurrentHashMap(内部使用了分段锁)、使用读写锁，读无锁，写加锁

### 性能的度量指标
- 吞吐量 单位时间内能处理的请求数量 吞吐量越大则说明性能越好
- 延迟 发出请求到收到响应的时间，延迟一般跟并发量挂钩 延迟越小则说明性能越好
- 并发量 指能同时处理的请求数量。一般情况下，并发量越大，延迟也会变大。
