# 学好理论有思路，关注细节定成败
## 理论部分总结
- 硬件的核心矛盾：CPU、内存、IO存在速率的问题，解决这个问题的时候，引入了可见性、原子性、有序性问题
- java内存模型解决可见性、有序性问题
- 锁来解决原子性问题
- 使用锁，针对性，共享资源和锁的对应关系，应该是N:1
- 锁的粒度问题，一不小心，容易死锁，死锁的原因
- 解决死锁的问题，wait-notify机制，同时引出了线程间的协作
- 安全性，活跃性，性能(延迟、吞吐量)，从宏观层面对前面的章节进行了总结
- 管程，解决并发编程的万能钥匙
- 并发问题是复杂的，因此介绍了线程的生命周期、多少线程数合理、局部变量是线程安全的
> 而多少线程数合理，往往根据不同的IO和CPU情况，理论数据是不同的，根据得到的公式，还需要根据实际情况进行压测来得到最佳线程数

## 注意点
- 锁的最佳实践
  - new Object，逃逸分析，代码会被优化掉，实际上相当于无锁结构
  - Integer，String不适合做锁，可变的对象一旦发生变化，则失去了互斥的功能
  - 锁应该是私有的、不可变的、不可重用的
- 锁的性能看场景
  - 每种技术方案都有对应的优缺点和适用场景
- 竞态条件需要格外注意
  - 当存在if条件
  - 多个线程安全的方法组合在一起时
- 方法调用是先计算参数
  - 日志打印的最佳方案是使用log.info("日志：{}",val);而非log.info("日志："+val)，因为方法调用是先计算参数，这里val变量会被计算，即使日记不打印，如果变量是共享变量的话，容易引发bug
-  InterruptException需要格外注意
  - interrupt的本意是中断，isInterrupted是判断线程是否被中断，而如果线程处于Waiting、time_waiting状态，interrupt的时候，线程抛出异常，此时会重置/清除中断标识，true->false，isInterrupted方法不起作用
- 理论值or经验值
  - 理论上讲，经验值肯定是靠不住的
  - IO耗时/CPU耗时，实践中肯定是大于1的，线程数基本上都是在初始值的基础上增加，增加过程中要注意延迟、吞吐量，当吞吐量开始不再增加或者下降时，延迟急速增多，基本上就是线程数的最佳数量了 

## 书籍
《java并发编程实战》《java安全编码标准》