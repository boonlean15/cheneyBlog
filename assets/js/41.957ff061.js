(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{352:function(t,v,_){"use strict";_.r(v);var a=_(27),s=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"安全性、活跃性、性能问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#安全性、活跃性、性能问题"}},[t._v("#")]),t._v(" 安全性、活跃性、性能问题")]),t._v(" "),v("h2",{attrs:{id:"安全性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#安全性"}},[t._v("#")]),t._v(" 安全性")]),t._v(" "),v("h3",{attrs:{id:"概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),v("blockquote",[v("p",[t._v("即正确性，程序按我们预期的执行，不要让我们感到意外")])]),t._v(" "),v("ul",[v("li",[t._v("线程安全的程序")])]),t._v(" "),v("blockquote",[v("p",[t._v("理论上线程安全的程序，就要避免出现原子性问题、可见性问题和有序性问题")])]),t._v(" "),v("h3",{attrs:{id:"保证线程安全性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#保证线程安全性"}},[t._v("#")]),t._v(" 保证线程安全性")]),t._v(" "),v("ul",[v("li",[t._v("不共享数据")]),t._v(" "),v("li",[t._v("数据状态不发生变化")])]),t._v(" "),v("blockquote",[v("p",[t._v("（线程本地存储、不变模式），然而现实中必须共享数据")])]),t._v(" "),v("h3",{attrs:{id:"数据竞争-竞态条件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据竞争-竞态条件"}},[t._v("#")]),t._v(" 数据竞争 竞态条件")]),t._v(" "),v("ul",[v("li",[t._v("数据竞争")])]),t._v(" "),v("blockquote",[v("p",[t._v("存在共享数据并且该数据会发生变化，通俗地讲就是有多个线程会同时读写同一数据")])]),t._v(" "),v("ul",[v("li",[t._v("竞态条件")])]),t._v(" "),v("blockquote",[v("p",[t._v("所谓竞态条件，指的是程序的执行结果依赖线程执行的顺序。或程序的执行依赖于某个状态变量")])]),t._v(" "),v("h3",{attrs:{id:"数据竞争和竞态条件问题-又该如何保证线程的安全性呢"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据竞争和竞态条件问题-又该如何保证线程的安全性呢"}},[t._v("#")]),t._v(" 数据竞争和竞态条件问题，又该如何保证线程的安全性呢")]),t._v(" "),v("blockquote",[v("p",[t._v("这两类问题，都可以用互斥这个技术方案，而实现互斥的方案有很多，CPU 提供了相关的互斥指令，操作系统、编程语言也会提供相关的 API。从逻辑上来看，我们可以统一归为：锁")])]),t._v(" "),v("h2",{attrs:{id:"活跃性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#活跃性"}},[t._v("#")]),t._v(" 活跃性")]),t._v(" "),v("h3",{attrs:{id:"概述-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述-2"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),v("blockquote",[v("p",[t._v("某个操作无法执行下去")])]),t._v(" "),v("h3",{attrs:{id:"死锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[t._v("#")]),t._v(" 死锁")]),t._v(" "),v("ul",[v("li",[t._v("概述")])]),t._v(" "),v("blockquote",[v("p",[t._v("一组互相竞争资源的线程互相等待，导致两个线程无休止的阻塞了")])]),t._v(" "),v("ul",[v("li",[t._v("出现原因")])]),t._v(" "),v("blockquote",[v("p",[t._v("互斥、占有且等待、不可抢占、循环等待")])]),t._v(" "),v("ul",[v("li",[t._v("解决方案")])]),t._v(" "),v("blockquote",[v("p",[t._v("打破导致死锁的条件：占有且等待(wait-notify)、不可抢占、循环等待(排序法获取锁)")])]),t._v(" "),v("h3",{attrs:{id:"活锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#活锁"}},[t._v("#")]),t._v(" 活锁")]),t._v(" "),v("ul",[v("li",[t._v("概述")])]),t._v(" "),v("blockquote",[v("p",[t._v("a谦让b，b谦让a，来来回回碰到,如人走路时。人灵活，可解决，机器不一定")])]),t._v(" "),v("ul",[v("li",[t._v("解决方案")])]),t._v(" "),v("blockquote",[v("p",[t._v("等待一个随机时间再谦让,Raft(分布式一致性算法)也有用到")])]),t._v(" "),v("h3",{attrs:{id:"饥饿"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#饥饿"}},[t._v("#")]),t._v(" 饥饿")]),t._v(" "),v("ul",[v("li",[t._v("概述")])]),t._v(" "),v("blockquote",[v("p",[t._v("无法访问所需资源导致无法执行下去")])]),t._v(" "),v("ul",[v("li",[t._v("出现原因")])]),t._v(" "),v("blockquote",[v("p",[t._v("不患寡而患不均，线程优先级不均，导致优先级低的线程执行机会很小。持有锁的线程执行时间过长")])]),t._v(" "),v("ul",[v("li",[t._v("解决方案")])]),t._v(" "),v("blockquote",[v("p",[t._v("有三种方案：一是保证资源充足，二是公平地分配资源，三就是避免持有锁的线程长时间执行")])]),t._v(" "),v("ul",[v("li",[t._v("公平地分配资源")])]),t._v(" "),v("blockquote",[v("p",[t._v("在并发编程里，主要是使用公平锁。所谓公平锁，是一种先来后到的方案，线程的等待是有顺序的，排在等待队列前面的线程会优先获得资源")])]),t._v(" "),v("h2",{attrs:{id:"性能"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#性能"}},[t._v("#")]),t._v(" 性能")]),t._v(" "),v("ul",[v("li",[t._v("概述")])]),t._v(" "),v("blockquote",[v("p",[t._v("使用锁要非常小心，但小心过度，则可能导致串行化的范围过大，导致性能问题。")])]),t._v(" "),v("h3",{attrs:{id:"串行百分比"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#串行百分比"}},[t._v("#")]),t._v(" 串行百分比")]),t._v(" "),v("ul",[v("li",[t._v("串行百分比")])]),t._v(" "),v("blockquote",[v("p",[t._v("临界区都是串行的，非临界区都是并行的，用单线程执行临界区的时间/用单线程执行(临界区+非临界区)的时间就是串行百分比")])]),t._v(" "),v("ul",[v("li",[t._v("阿姆达尔（Amdahl）定律 代表了处理器并行运算之后效率提升的能力")])]),t._v(" "),v("blockquote",[v("p",[t._v("s = 1 / ((1-p)+ (p/n)),其中p代表的是并行率，则1-p代表的是串行百分比，加入串行百分比是5%，那么无论我们采用什么技术，最多只能提高20倍性能")])]),t._v(" "),v("h3",{attrs:{id:"解决方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[t._v("#")]),t._v(" 解决方案")]),t._v(" "),v("ul",[v("li",[t._v("使用无锁数据结构和算法")])]),t._v(" "),v("blockquote",[v("p",[t._v("线程本地存储、写入时复制(copy-on-write)、乐观锁等。java sdk的原子类、disruptor无锁内存队列")])]),t._v(" "),v("ul",[v("li",[t._v("减少持有锁的时间")])]),t._v(" "),v("blockquote",[v("p",[t._v("例如使用细粒度的锁：concurrentHashMap(内部使用了分段锁)、使用读写锁，读无锁，写加锁")])]),t._v(" "),v("h3",{attrs:{id:"性能的度量指标"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#性能的度量指标"}},[t._v("#")]),t._v(" 性能的度量指标")]),t._v(" "),v("ul",[v("li",[t._v("吞吐量 单位时间内能处理的请求数量 吞吐量越大则说明性能越好")]),t._v(" "),v("li",[t._v("延迟 发出请求到收到响应的时间，延迟一般跟并发量挂钩 延迟越小则说明性能越好")]),t._v(" "),v("li",[t._v("并发量 指能同时处理的请求数量。一般情况下，并发量越大，延迟也会变大。")])]),t._v(" "),v("h2",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),v("p",[t._v("并发编程是一个复杂的技术领域，微观上涉及到原子性问题、可见性问题和有序性问题，宏观则表现为安全性、活跃性以及性能问题。")]),t._v(" "),v("p",[t._v("我们在设计并发程序的时候，主要是从宏观出发，也就是要重点关注它的安全性、活跃性以及性能。安全性方面要注意数据竞争和竞态条件，活跃性方面需要注意死锁、活锁、饥饿等问题，性能方面我们虽然介绍了两个方案(无锁数据结构和算法、减少锁持有的时间)")])])}),[],!1,null,null,null);v.default=s.exports}}]);