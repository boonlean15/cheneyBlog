(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{408:function(t,v,_){"use strict";_.r(v);var e=_(27),l=Object(e.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"netty的概念及体系结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#netty的概念及体系结构"}},[t._v("#")]),t._v(" Netty的概念及体系结构")]),t._v(" "),v("p",[t._v("netty是一款用于创建高性能网络应用程序的高级框架。第一部分，将深入的探究它的能力，并在三个方面进行示例：")]),t._v(" "),v("ul",[v("li",[t._v("使用Netty构建应用程序，你不必是一名网络编程专家")]),t._v(" "),v("li",[t._v("使用Netty比直接使用底层的java api 容易得多")]),t._v(" "),v("li",[t._v("Netty推崇良好的设计实践，例如，将你的应用程序逻辑和网络层解耦")])]),t._v(" "),v("p",[t._v("第1章，回顾java网络编程的演化过程，异步通信和事件驱动的处理。然后看一看Netty的核心组件。第2章，构建自己的第一款基于Netty的应用程序。开启对Netty的细致探究之旅（第3章），从它的核心网络协议(第4章)以及数据处理层(第5章和第6章)到它的并发模型(第7章).")]),t._v(" "),v("p",[t._v("把所有细节组合在一起，对第一部分进行总结。将看到：如何在运行时配置基于Netty的应用程序的各个组件，以使他们协同工作(第8章)，netty是如何帮助我们测试应用程序的(第9章)。")]),t._v(" "),v("h1",{attrs:{id:"netty-异步和事件驱动"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#netty-异步和事件驱动"}},[t._v("#")]),t._v(" Netty 异步和事件驱动")]),t._v(" "),v("ul",[v("li",[t._v("关注点分离 业务和网络逻辑解耦")]),t._v(" "),v("li",[t._v("模块化和可复用性")]),t._v(" "),v("li",[t._v("可测试性作为首要要求")])]),t._v(" "),v("h2",{attrs:{id:"java网络编程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java网络编程"}},[t._v("#")]),t._v(" java网络编程")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("阻塞IO")]),t._v(" "),v("blockquote",[v("p",[t._v("如：ServerSocker编程，服务端使用线程启动处理客户端请求")])]),t._v(" "),v("ul",[v("li",[t._v("缺点\n"),v("ul",[v("li",[t._v("在任何时候都可能有大量线程处于休眠状态，只是等待输入或输出数据就绪，是一种资源浪费")]),t._v(" "),v("li",[t._v("需要为每个线程的调用栈都分配内存，默认值为64kb到1mb，具体取决于操作系统")]),t._v(" "),v("li",[t._v("jvm在物理上可以支持非常大数量的线程，但在到达极限之前，上下文切换带来的开销就会带来麻烦")])])])])]),t._v(" "),v("li",[v("p",[t._v("JAVA NIO 非阻塞调用")]),t._v(" "),v("blockquote",[v("p",[t._v("setsockopt()，以便在读写调用没有数据时立刻返回、")])]),t._v(" "),v("blockquote",[v("p",[t._v("IO多路复用 selector编程")])])]),t._v(" "),v("li",[v("p",[t._v("选择器 Selector")]),t._v(" "),v("blockquote",[v("p",[t._v("通过注册非阻塞套接字的相关事件到选择器上，监听IO事件")])]),t._v(" "),v("blockquote",[v("p",[t._v("一个单一的线程可以处理多个并发的连接")])]),t._v(" "),v("ul",[v("li",[t._v("优点\n"),v("ul",[v("li",[t._v("使用较少的线程便可以处理许多连接，因此减少内存管理和上下文切换带来的开销")]),t._v(" "),v("li",[t._v("当没有IO操作需要处理时，线程可以被用于其他任务")])])])])])]),t._v(" "),v("h2",{attrs:{id:"netty简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#netty简介"}},[t._v("#")]),t._v(" netty简介")]),t._v(" "),v("ul",[v("li",[t._v("异步和事件驱动\n"),v("blockquote",[v("p",[t._v("netty是基于java NIO实现的异步的和事件驱动的网络框架")])])]),t._v(" "),v("li",[t._v("核心组件\n"),v("ul",[v("li",[t._v("Channel\n"),v("blockquote",[v("p",[t._v("一个打开输入输出的通道")])])]),t._v(" "),v("li",[t._v("Future\n"),v("blockquote",[v("p",[t._v("异步事件操作的结果的占位符")])])]),t._v(" "),v("li",[t._v("回调\n"),v("blockquote",[v("p",[t._v("其实就是一个方法的引用，被另一个方法调用")])])]),t._v(" "),v("li",[t._v("事件\n"),v("blockquote",[v("p",[t._v("netty使用不同的事件来通知我们状态的改变或者操作的状态")])])]),t._v(" "),v("li",[t._v("channelHandler\n"),v("blockquote",[v("p",[t._v("每个事件都可以分发给ChannelHandler。netty有一个ChannelHandler链，事件流经它们")])])])])])])])}),[],!1,null,null,null);v.default=l.exports}}]);