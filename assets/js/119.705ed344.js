(window.webpackJsonp=window.webpackJsonp||[]).push([[119],{429:function(s,a,t){"use strict";t.r(a);var l=t(27),e=Object(l.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"sql是如何执行的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sql是如何执行的"}},[s._v("#")]),s._v(" sql是如何执行的")]),s._v(" "),a("p",[s._v("想要写出高性能的sql，首先要了解它的原理，其次就是做大量的练习。")]),s._v(" "),a("h2",{attrs:{id:"oracle中的sql是如何执行的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#oracle中的sql是如何执行的"}},[s._v("#")]),s._v(" Oracle中的SQL是如何执行的")]),s._v(" "),a("img",{attrs:{width:"800",src:"https://boonlean15.github.io/cheneyBlog/images/sql/1.jpg",alt:"jpg"}}),s._v(" "),a("h3",{attrs:{id:"oracle执行过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#oracle执行过程"}},[s._v("#")]),s._v(" oracle执行过程")]),s._v(" "),a("ul",[a("li",[s._v("语法检查：检查sql拼写是否正确")]),s._v(" "),a("li",[s._v("语义检查：检查sql中的访问对象是否存在\n"),a("blockquote",[a("p",[s._v("语法检查和语义检查的作用是保证SQL语句没有错误")])])]),s._v(" "),a("li",[s._v("权限检查：看用户是否具备访问该数据的权限")]),s._v(" "),a("li",[s._v("共享池检查：共享池是一块内存池，主要作用是缓存sql语句和该语句的执行计划\n"),a("blockquote",[a("p",[s._v("Oracle通过检查共享池是否存在sql语句的执行计划，来判断进行软解析还是硬解析。\n在共享池中，oracle对sql语句进行hash运算，根据hash值在库缓存中查找，如果存在sql语句执行计划，就直接拿来执行，直接进入执行器的环节，这就是软解析。\n如果没有找到sql语句执行计划，oracle需要创建解析树进行解析，生成执行计划，进入“优化器”这个步骤，这就是硬解析。")])])]),s._v(" "),a("li",[s._v("优化器：优化器中就是要进行硬解析，也就是决定怎么做，比如创建解析树，生成执行计划")]),s._v(" "),a("li",[s._v("执行器：有了解析树和执行计划后，就知道sql该怎么被执行，这样就可以在执行器中执行语句了")])]),s._v(" "),a("h3",{attrs:{id:"共享池"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#共享池"}},[s._v("#")]),s._v(" 共享池")]),s._v(" "),a("ul",[a("li",[s._v("共享池：oracle的术语，包括了库缓存，数据字典缓冲区等\n"),a("ul",[a("li",[s._v("库缓存：主要缓存sql语句和执行计划。决定sql语句是否需要进行硬解析\n"),a("blockquote",[a("p",[s._v("创建解析树、生成执行计划很消耗资源，应尽量避免硬解析")])])]),s._v(" "),a("li",[s._v("数据字典缓冲区：存储oracle中的对象定义，如表、视图、索引等对象\n"),a("blockquote",[a("p",[s._v("当对sql语句进行解析时，如果需要相关的数据，会从数据字典缓冲区中提取")])])])])])]),s._v(" "),a("h3",{attrs:{id:"oracle绑定变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#oracle绑定变量"}},[s._v("#")]),s._v(" oracle绑定变量")]),s._v(" "),a("p",[s._v("oracle绑定变量是它的一大特色，绑定变量就是在sql语句中使用变量，通过不同变量的取值来改变sql的执行结果。")]),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" player "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("where")]),s._v(" player_id "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10001")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("--- 使用绑定变量")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" player "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("where")]),s._v(" player_id "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" :player_id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("ul",[a("li",[s._v("绑定变量的好处\n"),a("ul",[a("li",[s._v("提升软解析的可能性")])])]),s._v(" "),a("li",[s._v("缺点\n"),a("ul",[a("li",[s._v("可能导致生成的执行计划不够优化")])])])]),s._v(" "),a("h4",{attrs:{id:"如何避免硬解析-尽量使用软解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何避免硬解析-尽量使用软解析"}},[s._v("#")]),s._v(" 如何避免硬解析，尽量使用软解析")]),s._v(" "),a("p",[a("strong",[s._v("通过绑定变量")])]),s._v(" "),a("blockquote",[a("p",[s._v("在查询 player_id = 10001 之后，还会查询 10002、10003 之类的数据，那么每一次查询都会创建一个新的查询解析。\n而第二种方式使用了绑定变量，那么在第一次查询之后，在共享池中就会存在这类查询的执行计划，也就是软解析。\n使用动态SQL 的方式，因为参数不同，会导致 SQL 的执行效率不同，同时 SQL 优化也会比较困难。")])]),s._v(" "),a("h2",{attrs:{id:"mysql-中的-sql-是如何执行的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql-中的-sql-是如何执行的"}},[s._v("#")]),s._v(" MySQL 中的 SQL 是如何执行的")]),s._v(" "),a("p",[s._v("Mysql是典型的C/S架构，Client/Server架构，服务器端程序使用的mysqld。\n"),a("img",{attrs:{width:"800",src:"https://boonlean15.github.io/cheneyBlog/images/sql/2.jpg",alt:"jpg"}})]),s._v(" "),a("ul",[a("li",[s._v("连接层：客户端和服务器端建立连接，客户端发送sql服务器端")]),s._v(" "),a("li",[s._v("sql层：对sql语句进行查询处理\n"),a("img",{attrs:{width:"800",src:"https://boonlean15.github.io/cheneyBlog/images/sql/3.jpg",alt:"jpg"}}),s._v(" "),a("ul",[a("li",[s._v("查询缓存：server如果在查询缓存中发现这个sql语句，直接将结果返回给客户端；如果没有则进入到解析器阶段。(查询缓存往往效率不高，mysql8.0之后抛弃了这个功能)")]),s._v(" "),a("li",[s._v("解析器：对sql语句进行语法分析，语义分析")]),s._v(" "),a("li",[s._v("优化器：确定sql语句的执行路径，比如：根据全表检索还是根据索引检索等")]),s._v(" "),a("li",[s._v("执行器：执行之前判断用户是否具备权限，具备则执行sql并返回结果。mysql8以下，如果设置了查询缓存，会将查询结果进行缓存")])])]),s._v(" "),a("li",[s._v("存储引擎层：与数据库文件打交道，负责数据的存储和读取")])]),s._v(" "),a("h3",{attrs:{id:"mysql的存储引擎"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql的存储引擎"}},[s._v("#")]),s._v(" Mysql的存储引擎")]),s._v(" "),a("p",[s._v("与oracle不同的是，mysql的存储引擎采用了插件的形式，每个存储引擎都面向一种特定的数据库应用环境。同时开源的mysql允许开发人员设置自己的存储引擎")]),s._v(" "),a("ul",[a("li",[s._v("InnoDB：mysql5.5版本之后默认的存储引擎，最大的特点是支持事务、行级锁定、外键约束等")]),s._v(" "),a("li",[s._v("MyISAM：mysql5.5之前默认的存储引擎，不支持事务、不支持外键，最大的特点是快，占用资源少")]),s._v(" "),a("li",[s._v("Memory：使用系统内存作为存储介质，以得到更快的响应速度。如果mysqld进程崩溃，则会导致所有数据丢失，当数据是临时的情况下才使用Memory")]),s._v(" "),a("li",[s._v("NDB：也叫所NDB Cluster存储引擎，主要用于Mysql Cluster分布式集群环境，类似Oracle的RAC集群")]),s._v(" "),a("li",[s._v("Archive：有很好的压缩机制，用于文件归档，在请求写入时会进行压缩，所有常用来做仓库")])]),s._v(" "),a("h3",{attrs:{id:"mysql的强大之处"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql的强大之处"}},[s._v("#")]),s._v(" Mysql的强大之处")]),s._v(" "),a("p",[s._v("数据库的设计在于表的设计，而在Mysql的每个表设计中，可以采用不同的存储引擎，我们可以根据实际的数据处理需求选择存储引擎")]),s._v(" "),a("h2",{attrs:{id:"数据库管理系统也是一种软件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库管理系统也是一种软件"}},[s._v("#")]),s._v(" 数据库管理系统也是一种软件")]),s._v(" "),a("p",[s._v("简单的把mysql和oracle看成数据库管理系统软件，从外部看难免晦涩难懂，毕竟组织结构太多了。\n学习的时候，需要具备抽象的能力抓取最核心的部分"),a("strong",[s._v("sql的执行原理")]),s._v("，不同的DBMS的sql的执行原理是相通的，只是在不同的软件中，各有各的实现路径。")]),s._v(" "),a("h3",{attrs:{id:"mysql中一条sql语句的执行时间分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql中一条sql语句的执行时间分析"}},[s._v("#")]),s._v(" mysql中一条sql语句的执行时间分析")]),s._v(" "),a("ul",[a("li",[s._v("开启profiling：mysql收集在sql执行时所使用的资源情况")])]),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("--- 0 代表关闭，1代表打开")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" @"),a("span",{pre:!0,attrs:{class:"token variable"}},[s._v("@profiling")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("set")]),s._v(" profiling"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("---查看当前会话所产生的所有 profiles")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("show")]),s._v(" profiles"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("img",{attrs:{width:"800",src:"https://boonlean15.github.io/cheneyBlog/images/sql/4.jpg",alt:"jpg"}}),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("--- 获取上一次查询的执行时间")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("show")]),s._v(" profile"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("--- 查询指定的 Query ID")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("show")]),s._v(" profile "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),s._v(" query "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("img",{attrs:{width:"800",src:"https://boonlean15.github.io/cheneyBlog/images/sql/5.jpg",alt:"jpg"}}),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("--- 查看 MySQL 的版本情况")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" version"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("img",{attrs:{width:"800",src:"https://boonlean15.github.io/cheneyBlog/images/sql/6.jpg",alt:"jpg"}}),s._v(" "),a("ul",[a("li",[s._v("一旦数据表有更新，缓存都将清空\n"),a("blockquote",[a("p",[s._v("因此只有数据表是静态的时候，或者数据表很少发生变化时，使用缓存查询才有价值")])])]),s._v(" "),a("li",[s._v("如果数据表经常更新，反而增加了SQL 的查询时间")])]),s._v(" "),a("h2",{attrs:{id:"oracle和mysql的sql执行过程区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#oracle和mysql的sql执行过程区别"}},[s._v("#")]),s._v(" oracle和mysql的sql执行过程区别")]),s._v(" "),a("h3",{attrs:{id:"相同点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相同点"}},[s._v("#")]),s._v(" 相同点")]),s._v(" "),a("ul",[a("li",[s._v("oracle和mysql都是通过解析器->优化器->执行器这样的流程执行sql的")])]),s._v(" "),a("h3",{attrs:{id:"差异"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#差异"}},[s._v("#")]),s._v(" 差异")]),s._v(" "),a("ul",[a("li",[s._v("oracle提出共享池概念，通过共享池判断进行软解析还是硬解析")]),s._v(" "),a("li",[s._v("mysql8之后不再支持查询缓存，而是直接执行解析器->优化器->执行器的流程")]),s._v(" "),a("li",[s._v("mysql的一大特色是提供了各种存储引擎以供选择，不同的存储引擎有各自的使用场景，可以针对每张表选择适合的存储引擎")])])])}),[],!1,null,null,null);a.default=e.exports}}]);