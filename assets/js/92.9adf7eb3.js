(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{432:function(n,e,a){"use strict";a.r(e);var t=a(27),l=Object(t.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"netty组件和设计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#netty组件和设计"}},[n._v("#")]),n._v(" netty组件和设计")]),n._v(" "),e("h2",{attrs:{id:"channel、-eventloop、channelfuture"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#channel、-eventloop、channelfuture"}},[n._v("#")]),n._v(" Channel、 EventLoop、ChannelFuture")]),n._v(" "),e("h3",{attrs:{id:"channel"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#channel"}},[n._v("#")]),n._v(" channel")]),n._v(" "),e("blockquote",[e("p",[n._v("输入输出的一个通道channel")])]),n._v(" "),e("ul",[e("li",[n._v("基本的IO操作依赖于网络传输所提供的原语 bind()、connect()、read()、write()")]),n._v(" "),e("li",[n._v("基于java的网络编程中，基本构造是class socket")]),n._v(" "),e("li",[n._v("使用netty提供的channel，降低了直接使用socker的复杂度\n"),e("ul",[e("li",[n._v("netty有很多预定义的channel：Embeddedchannel、LocalServerChannel、NioSocketChannel")])])])]),n._v(" "),e("h3",{attrs:{id:"eventloop"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#eventloop"}},[n._v("#")]),n._v(" EventLoop")]),n._v(" "),e("blockquote",[e("p",[n._v("定义了Netty的核心抽象，处理连接的生命周期中所发生的事件")])]),n._v(" "),e("ul",[e("li",[n._v("一个EventLoopGroup 包含一个或多个EventLoop")]),n._v(" "),e("li",[n._v("一个EventLoop的生命周期内只与一个Thread绑定")]),n._v(" "),e("li",[n._v("所有由EventLoop处理的IO事件都将在它专有的Thread上被处理")]),n._v(" "),e("li",[n._v("一个channel在它的生命周期内只注册于一个EventLoop")]),n._v(" "),e("li",[n._v("一个EventLoop可以被分配给一个或多个Channel\n"),e("blockquote",[e("p",[n._v("一个channel的io事件是相同的Thread执行的，消除了同步的需要")])])])]),n._v(" "),e("h3",{attrs:{id:"channelfuture"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#channelfuture"}},[n._v("#")]),n._v(" ChannelFuture")]),n._v(" "),e("blockquote",[e("p",[n._v("netty的io操作都是异步的，可以看作是将来要执行的操作的结果的占位符，和java的Future类似")])]),n._v(" "),e("ul",[e("li",[n._v("不能保证它什么时候被执行，但一定会被执行。此外，属于同一个channel的操作，保证它们以被调用的顺序被执行")])]),n._v(" "),e("h2",{attrs:{id:"channelhandler、-channelpipeline"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#channelhandler、-channelpipeline"}},[n._v("#")]),n._v(" ChannelHandler、 ChannelPipeline")]),n._v(" "),e("h3",{attrs:{id:"channelhandler"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#channelhandler"}},[n._v("#")]),n._v(" ChannelHandler")]),n._v(" "),e("blockquote",[e("p",[n._v("处理入站和出站数据的应用程序逻辑的容器。专门用于几乎任何类型的动作，如数据格式转换，处理异常等")])]),n._v(" "),e("ul",[e("li",[n._v("举例：比如经常实现的一个子接口ChannelInboundHandler，用于处理入站数据和事件")]),n._v(" "),e("li",[n._v("应用程序的逻辑通常驻留在一个或多个ChannelInboundHandler中")])]),n._v(" "),e("h3",{attrs:{id:"channelpipeline"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#channelpipeline"}},[n._v("#")]),n._v(" ChannelPipeline")]),n._v(" "),e("blockquote",[e("p",[n._v("channelPipeline为channelhandler链提供了容器，并定义了用于在该链上传播入站和出站事件流的API")])]),n._v(" "),e("blockquote",[e("p",[n._v("channelHandler是处理往来ChannelPipeline事件或数据的任何代码的通用容器")])]),n._v(" "),e("h4",{attrs:{id:"channelhandler安装到channelpipeline的过程如下"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#channelhandler安装到channelpipeline的过程如下"}},[n._v("#")]),n._v(" ChannelHandler安装到ChannelPipeline的过程如下：")]),n._v(" "),e("ul",[e("li",[n._v("一个ChannelInitializer的实现被注册到ServerBootstrap中")]),n._v(" "),e("li",[n._v("当ChannelInitializer.initChannel被调用，ChannelInitializer将在ChannelPipeline中安装一组自定义的ChannelHandler")]),n._v(" "),e("li",[n._v("ChannelInitializer将它自己从ChannelPipeline中移除")])]),n._v(" "),e("h3",{attrs:{id:"channelhandler链特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#channelhandler链特点"}},[n._v("#")]),n._v(" ChannelHandler链特点")]),n._v(" "),e("ul",[e("li",[n._v("ChannelHandler是专门用于处理往来ChannelPipeline链的，，从它的实现ChannelInboundHandlerAdapter和ChannelOutboundHandlerAdapter可以看出")]),n._v(" "),e("li",[n._v("Inbound类型和Outbound类型可以被添加到ChannelHandler链中，但是netty可以识别它，以保证入站数据只在Inbound之间传播，出站数据只在Outbound传播")]),n._v(" "),e("li",[n._v("入站流向和出站流向-顺序 (channelHandler的顺序是按被添加到ChannelPipeline的顺序决定的)")]),n._v(" "),e("li",[e("strong",[n._v("可以通过作为参数传递到每个方法的ChannelHandlerContext，事件可以被传递到ChannelHandler链的下一个ChannelHandler中，默认实现是传递给下一个ChannelHandler")])])]),n._v(" "),e("div",{staticClass:"language-java extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[n._v("@Skip")]),n._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("public")]),n._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("void")]),n._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[n._v("channelActive")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[n._v("ChannelHandlerContext")]),n._v(" ctx"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("throws")]),n._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[n._v("Exception")]),n._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n    ctx"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[n._v("fireChannelActive")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n")])])]),e("h3",{attrs:{id:"channelhandlercontext"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#channelhandlercontext"}},[n._v("#")]),n._v(" ChannelHandlerContext")]),n._v(" "),e("blockquote",[e("p",[n._v("ChannelHandler添加到channelPipeline时，会分配一个ChannelHandlerContext，代表ChannelHandler和ChannelPipeline之间的绑定。"),e("strong",[n._v("它可以获取底层的Channel")])])]),n._v(" "),e("h3",{attrs:{id:"netty中发送消息的方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#netty中发送消息的方式"}},[n._v("#")]),n._v(" "),e("strong",[n._v("Netty中发送消息的方式")])]),n._v(" "),e("ul",[e("li",[n._v("直接写到channel 从Pipeline的尾部开始流动")]),n._v(" "),e("li",[n._v("写到ChannelHandlerContext 从ChannelPipeline的下一个Handler开始流动")])]),n._v(" "),e("h2",{attrs:{id:"编码器、解码器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#编码器、解码器"}},[n._v("#")]),n._v(" 编码器、解码器")]),n._v(" "),e("blockquote",[e("p",[n._v("网络的传输都是字节，所以需要编码器和解码器，比如我们java程序，需要的是一个java对象，那么编码器和解码器的作用便是把对象编码为字节，字节解码为java对象")])]),n._v(" "),e("h3",{attrs:{id:"编码器命名规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#编码器命名规则"}},[n._v("#")]),n._v(" 编码器命名规则")]),n._v(" "),e("blockquote",[e("p",[n._v("类似于ByteToMessageDecoder、MessageToByteEncode，还有专为Google的protocol 的ProtobufDecoder，ProtobufEncoder")])]),n._v(" "),e("h3",{attrs:{id:"netty内置的编解码器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#netty内置的编解码器"}},[n._v("#")]),n._v(" netty内置的编解码器")]),n._v(" "),e("blockquote",[e("p",[n._v("跟ChannelHandler适配器一样，编码解码器也有预定义的一些适配器。并且继承了ChannelInboundHandler或ChannelOutboundHandler")])]),n._v(" "),e("h3",{attrs:{id:"数据流流经编码器或解码器流向"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据流流经编码器或解码器流向"}},[n._v("#")]),n._v(" 数据流流经编码器或解码器流向")]),n._v(" "),e("blockquote",[e("p",[n._v("channelRead0方法已经被重写 -> 每个从入站数据读取的消息，都会调用此方法 -> 调用预置编码器的decode方法 -> 转发给channelpipeline的下一个ChannelHandler")])]),n._v(" "),e("p",[n._v("出站消息则是入站消息的反方向")]),n._v(" "),e("h2",{attrs:{id:"simplechannelinboundhandler"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#simplechannelinboundhandler"}},[n._v("#")]),n._v(" SimpleChannelInboundHandler")]),n._v(" "),e("blockquote",[e("p",[n._v("最常见的情况是继承它，然后重写channelRead0方法，自定义业务处理逻辑。除了要求不阻塞当前IO线程")])]),n._v(" "),e("h2",{attrs:{id:"引导"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#引导"}},[n._v("#")]),n._v(" 引导")]),n._v(" "),e("blockquote",[e("p",[n._v("为应用程序的网络层配置提供了容器")])]),n._v(" "),e("h3",{attrs:{id:"serverbootstrap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#serverbootstrap"}},[n._v("#")]),n._v(" ServerBootstrap")]),n._v(" "),e("ul",[e("li",[n._v("将一个进程绑定到指定端口")]),n._v(" "),e("li",[n._v("服务端使用")]),n._v(" "),e("li",[n._v("2个EventLoopGroup 一个serverChannel用于服务器自身绑定到某个本地端口的正在监听到套接字、另外一个用于传入客户端连接的channel")]),n._v(" "),e("li",[n._v("与ServerChannel相关联的EventLoopGroup将分配一个负责为传入连接请求创建Channel的EventLoop。一旦连接被建立，第二个EventLoopGroup就会给它的Channel分配EventLoop")])]),n._v(" "),e("h3",{attrs:{id:"bootstrap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bootstrap"}},[n._v("#")]),n._v(" Bootstrap")]),n._v(" "),e("ul",[e("li",[n._v("将一个进程连接到另一个运行在指定主机的指定端口的进程")]),n._v(" "),e("li",[n._v("客户端使用")]),n._v(" "),e("li",[n._v("1个EventLoopGroup")])])])}),[],!1,null,null,null);e.default=l.exports}}]);